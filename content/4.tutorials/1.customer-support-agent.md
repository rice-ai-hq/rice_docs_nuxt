---
title: "Tutorial 1: Customer Support Agent"
description: Build a customer support agent that learns from past tickets and maintains conversation context.
navigation:
  icon: i-lucide-headphones
seo:
  title: "Building a Customer Support Agent with Rice Slate"
  description: Comprehensive tutorial on building an intelligent customer support agent that learns from experience.
---

# Building a Customer Support Agent

In this tutorial, you'll build a production-ready customer support agent that:

- Maintains context across multi-turn conversations
- Learns from past support interactions to improve responses
- Recalls customer preferences and history
- Escalates complex issues to human agents
- Uses deterministic procedures for refunds and account actions

---

## Overview

### The Problem

Traditional chatbots are statelessâ€”they don't remember past conversations, can't learn from successful resolutions, and treat every customer as a stranger. This leads to:

- Customers repeating themselves
- Inconsistent responses to similar issues
- No improvement over time
- Frustrated users and support teams

### Our Solution

We'll build a cognitive support agent using Rice Slate's three memory systems:

| Memory Type | Purpose in This Agent |
| :---------- | :-------------------- |
| **Working Memory** | Current conversation context, customer sentiment, issue state |
| **Episodic Memory** | Past ticket resolutions, customer interaction history |
| **Procedural Memory** | Refund calculations, account status checks, escalation rules |

---

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Customer Message                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   1. PERCEIVE & CLASSIFY                     â”‚
â”‚  - Extract intent (billing, technical, general)              â”‚
â”‚  - Detect sentiment (frustrated, neutral, happy)             â”‚
â”‚  - Identify customer ID                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   2. RECALL (Episodic Memory)                â”‚
â”‚  - Search for similar past tickets                           â”‚
â”‚  - Retrieve this customer's history                          â”‚
â”‚  - Find successful resolution patterns                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   3. ORIENT (Working Memory)                 â”‚
â”‚  - Get current conversation state                            â”‚
â”‚  - Retrieve ongoing issue context                            â”‚
â”‚  - Check escalation status                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   4. DECIDE (LLM)                            â”‚
â”‚  - Generate response with full context                       â”‚
â”‚  - Determine if action needed (refund, escalate, etc.)       â”‚
â”‚  - Assess confidence level                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   5. ACT                                     â”‚
â”‚  - Execute Procedural Memory skills if needed                â”‚
â”‚  - Send response to customer                                 â”‚
â”‚  - Trigger escalation if required                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   6. LEARN & UPDATE                          â”‚
â”‚  - Commit interaction to Episodic Memory                     â”‚
â”‚  - Update Working Memory with new state                      â”‚
â”‚  - Record outcome for future learning                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Setup

### Project Structure

```
customer-support-agent/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ agent.ts              # Main agent logic
â”‚   â”œâ”€â”€ memory.ts             # Rice Slate integration
â”‚   â”œâ”€â”€ llm.ts                # LLM client wrapper
â”‚   â”œâ”€â”€ types.ts              # TypeScript interfaces
â”‚   â””â”€â”€ skills/
â”‚       â”œâ”€â”€ refund.ts         # Refund calculation logic
â”‚       â””â”€â”€ escalation.ts     # Escalation rules
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ agent.test.ts
â”œâ”€â”€ package.json
â””â”€â”€ .env
```

### Dependencies

```bash
# Clone Rice Slate clients
git clone https://github.com/rice-ai-hq/rice_slate.git

# Create project
mkdir customer-support-agent && cd customer-support-agent
npm init -y

# Install dependencies
npm install dotenv openai
npm install -D typescript @types/node ts-node

# Link Rice Slate client (adjust path as needed)
npm link ../rice_slate/clients/node
```

### Environment Variables

```bash
# .env
SLATE_ADDRESS=localhost:50051
SLATE_TOKEN=your-auth-token
OPENAI_API_KEY=your-openai-key
```

---

## Implementation

### Step 1: Define Types

First, let's define the core types for our agent:

```typescript
// src/types.ts

export interface Customer {
  id: string;
  name: string;
  email: string;
  tier: "free" | "pro" | "enterprise";
  accountAge: number; // days
}

export interface Message {
  role: "customer" | "agent";
  content: string;
  timestamp: Date;
}

export interface Ticket {
  id: string;
  customerId: string;
  status: "open" | "resolved" | "escalated";
  category: "billing" | "technical" | "general" | "account";
  priority: "low" | "medium" | "high" | "urgent";
  messages: Message[];
  createdAt: Date;
  resolvedAt?: Date;
}

export interface ConversationState {
  ticketId: string;
  customerId: string;
  currentIntent: string;
  sentiment: "frustrated" | "neutral" | "satisfied";
  issuesSummary: string;
  attemptedSolutions: string[];
  escalationRisk: number; // 0-1
}

export interface PastResolution {
  input: string;
  outcome: string;
  action: string;
  reasoning: string;
  wasSuccessful: boolean;
  customerSatisfaction: number; // 1-5
}
```

### Step 2: Create the Memory Manager

This class encapsulates all Rice Slate interactions:

```typescript
// src/memory.ts

import { CortexClient } from "./rice_slate/clients/node/dist";
import { ConversationState, PastResolution, Customer } from "./types";

export class SupportMemory {
  private client: CortexClient;

  constructor(address: string, token: string) {
    this.client = new CortexClient(address, token);
  }

  // ============================================
  // WORKING MEMORY - Current conversation state
  // ============================================

  async updateConversationState(state: ConversationState): Promise<void> {
    // Store structured state in working memory
    await this.client.focus(
      JSON.stringify({
        type: "conversation_state",
        ticketId: state.ticketId,
        ...state,
      })
    );
  }

  async addToConversation(
    ticketId: string,
    role: string,
    content: string
  ): Promise<void> {
    await this.client.focus(
      JSON.stringify({
        type: "message",
        ticketId,
        role,
        content,
        timestamp: new Date().toISOString(),
      })
    );
  }

  async getCurrentContext(): Promise<any[]> {
    const items = await this.client.drift();
    return items.map((item) => {
      try {
        return JSON.parse(item.content);
      } catch {
        return { type: "text", content: item.content };
      }
    });
  }

  async getConversationHistory(ticketId: string): Promise<any[]> {
    const context = await this.getCurrentContext();
    return context.filter(
      (item) => item.ticketId === ticketId && item.type === "message"
    );
  }

  // ============================================
  // EPISODIC MEMORY - Past experiences
  // ============================================

  async recordResolution(
    customerQuery: string,
    resolution: string,
    action: string,
    reasoning: string,
    metadata: {
      category: string;
      wasSuccessful: boolean;
      customerSatisfaction?: number;
    }
  ): Promise<void> {
    await this.client.commit(customerQuery, resolution, {
      action,
      reasoning: JSON.stringify({
        reasoning,
        ...metadata,
      }),
    });
  }

  async findSimilarIssues(query: string, limit: number = 5): Promise<any[]> {
    const traces = await this.client.reminisce(query);
    return traces.slice(0, limit).map((trace) => ({
      originalIssue: trace.input,
      resolution: trace.outcome,
      action: trace.action,
      metadata: JSON.parse(trace.reasoning || "{}"),
    }));
  }

  async getCustomerHistory(customerId: string): Promise<any[]> {
    // Search for past interactions with this customer
    return await this.findSimilarIssues(`customer:${customerId}`);
  }

  // ============================================
  // PROCEDURAL MEMORY - Deterministic skills
  // ============================================

  async calculateRefund(params: {
    orderId: string;
    reason: string;
    daysSincePurchase: number;
    orderTotal: number;
    customerTier: string;
  }): Promise<{ eligible: boolean; amount: number; policy: string }> {
    // In production, this would call client.trigger("calculate_refund")
    // For now, we implement the logic directly
    const { daysSincePurchase, orderTotal, customerTier, reason } = params;

    // Refund policy rules
    let eligible = false;
    let percentage = 0;
    let policy = "";

    if (daysSincePurchase <= 30) {
      eligible = true;
      percentage = 100;
      policy = "Full refund within 30-day window";
    } else if (daysSincePurchase <= 60 && customerTier === "enterprise") {
      eligible = true;
      percentage = 100;
      policy = "Enterprise: Extended 60-day full refund";
    } else if (daysSincePurchase <= 60) {
      eligible = true;
      percentage = 50;
      policy = "50% refund in 30-60 day window";
    } else if (reason === "product_defect") {
      eligible = true;
      percentage = 100;
      policy = "Full refund for product defects (any time)";
    } else {
      eligible = false;
      percentage = 0;
      policy = "Outside refund window (60 days)";
    }

    return {
      eligible,
      amount: (orderTotal * percentage) / 100,
      policy,
    };
  }

  async checkEscalationCriteria(state: ConversationState): Promise<{
    shouldEscalate: boolean;
    reason: string;
    priority: string;
  }> {
    // Deterministic escalation rules
    const reasons: string[] = [];

    if (state.sentiment === "frustrated" && state.escalationRisk > 0.7) {
      reasons.push("High frustration with escalation risk");
    }

    if (state.attemptedSolutions.length >= 3) {
      reasons.push("Multiple solution attempts failed");
    }

    // Add more rules as needed

    const shouldEscalate = reasons.length > 0;
    const priority =
      state.escalationRisk > 0.8
        ? "urgent"
        : state.escalationRisk > 0.5
          ? "high"
          : "medium";

    return {
      shouldEscalate,
      reason: reasons.join("; "),
      priority,
    };
  }
}
```

### Step 3: Create the LLM Client

Wrap your LLM API for consistent interaction:

```typescript
// src/llm.ts

import OpenAI from "openai";

export class LLMClient {
  private openai: OpenAI;

  constructor(apiKey: string) {
    this.openai = new OpenAI({ apiKey });
  }

  async generateResponse(params: {
    systemPrompt: string;
    conversationHistory: any[];
    pastResolutions: any[];
    currentMessage: string;
    customerInfo: any;
  }): Promise<{
    response: string;
    suggestedAction: string | null;
    confidence: number;
    reasoning: string;
  }> {
    const { systemPrompt, conversationHistory, pastResolutions, currentMessage, customerInfo } =
      params;

    // Build context from past resolutions
    const pastExamplesText =
      pastResolutions.length > 0
        ? `\n\nRELEVANT PAST RESOLUTIONS:\n${pastResolutions
            .map(
              (r, i) =>
                `Example ${i + 1}:
          Issue: ${r.originalIssue}
          Resolution: ${r.resolution}
          Action: ${r.action}
          Success: ${r.metadata.wasSuccessful ? "Yes" : "No"}`
            )
            .join("\n\n")}`
        : "";

    // Build conversation context
    const conversationText = conversationHistory
      .map((m) => `${m.role.toUpperCase()}: ${m.content}`)
      .join("\n");

    const fullPrompt = `${systemPrompt}

CUSTOMER INFO:
- Name: ${customerInfo.name}
- Tier: ${customerInfo.tier}
- Account Age: ${customerInfo.accountAge} days
${pastExamplesText}

CONVERSATION SO FAR:
${conversationText}

CURRENT MESSAGE:
CUSTOMER: ${currentMessage}

Respond in JSON format:
{
  "response": "Your response to the customer",
  "suggestedAction": "refund|escalate|close_ticket|null",
  "confidence": 0.0-1.0,
  "reasoning": "Brief explanation of your approach"
}`;

    const completion = await this.openai.chat.completions.create({
      model: "gpt-4",
      messages: [{ role: "user", content: fullPrompt }],
      temperature: 0.7,
      response_format: { type: "json_object" },
    });

    const result = JSON.parse(completion.choices[0].message.content || "{}");

    return {
      response: result.response || "I apologize, I encountered an issue. Let me connect you with a human agent.",
      suggestedAction: result.suggestedAction || null,
      confidence: result.confidence || 0.5,
      reasoning: result.reasoning || "",
    };
  }

  async classifyIntent(message: string): Promise<{
    intent: string;
    sentiment: "frustrated" | "neutral" | "satisfied";
    entities: Record<string, string>;
  }> {
    const completion = await this.openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: `Classify the customer message. Return JSON:
{
  "intent": "billing|technical|account|general|refund|complaint",
  "sentiment": "frustrated|neutral|satisfied",
  "entities": { "orderId": "...", "product": "...", etc. }
}`,
        },
        { role: "user", content: message },
      ],
      response_format: { type: "json_object" },
    });

    return JSON.parse(completion.choices[0].message.content || "{}");
  }
}
```

### Step 4: Build the Main Agent

Now we tie everything together:

```typescript
// src/agent.ts

import { SupportMemory } from "./memory";
import { LLMClient } from "./llm";
import { Customer, ConversationState, Ticket } from "./types";

export class CustomerSupportAgent {
  private memory: SupportMemory;
  private llm: LLMClient;

  private readonly SYSTEM_PROMPT = `You are a helpful, empathetic customer support agent for TechCorp.

GUIDELINES:
- Be concise but thorough
- Show empathy for frustrated customers
- Offer concrete solutions, not vague promises
- If you can resolve the issue, do so
- If you need to escalate, explain why to the customer
- Use past successful resolutions as examples when relevant
- Never promise something you can't deliver

AVAILABLE ACTIONS:
- refund: Process a refund (will check eligibility automatically)
- escalate: Transfer to human agent
- close_ticket: Mark issue as resolved
- null: Continue conversation (no action needed)`;

  constructor(slateAddress: string, slateToken: string, openaiKey: string) {
    this.memory = new SupportMemory(slateAddress, slateToken);
    this.llm = new LLMClient(openaiKey);
  }

  async handleMessage(
    ticket: Ticket,
    customer: Customer,
    message: string
  ): Promise<{
    response: string;
    actionTaken: string | null;
    ticketStatus: string;
  }> {
    console.log(`\n[Agent] Processing message for ticket ${ticket.id}`);

    // =========================================
    // STEP 1: PERCEIVE - Classify the message
    // =========================================
    console.log("[Agent] Step 1: Classifying intent...");
    const classification = await this.llm.classifyIntent(message);
    console.log(`[Agent] Intent: ${classification.intent}, Sentiment: ${classification.sentiment}`);

    // Store the incoming message in working memory
    await this.memory.addToConversation(ticket.id, "customer", message);

    // =========================================
    // STEP 2: RECALL - Find similar past issues
    // =========================================
    console.log("[Agent] Step 2: Searching for similar past issues...");
    const similarIssues = await this.memory.findSimilarIssues(message);
    console.log(`[Agent] Found ${similarIssues.length} similar past issues`);

    // Also get this customer's history
    const customerHistory = await this.memory.getCustomerHistory(customer.id);
    console.log(`[Agent] Customer has ${customerHistory.length} past interactions`);

    // =========================================
    // STEP 3: ORIENT - Get current context
    // =========================================
    console.log("[Agent] Step 3: Loading conversation context...");
    const conversationHistory = await this.memory.getConversationHistory(ticket.id);

    // Build current state
    const currentState: ConversationState = {
      ticketId: ticket.id,
      customerId: customer.id,
      currentIntent: classification.intent,
      sentiment: classification.sentiment,
      issuesSummary: message,
      attemptedSolutions: [],
      escalationRisk: classification.sentiment === "frustrated" ? 0.6 : 0.2,
    };

    // =========================================
    // STEP 4: DECIDE - Generate response
    // =========================================
    console.log("[Agent] Step 4: Generating response...");
    const llmResult = await this.llm.generateResponse({
      systemPrompt: this.SYSTEM_PROMPT,
      conversationHistory,
      pastResolutions: similarIssues,
      currentMessage: message,
      customerInfo: customer,
    });

    console.log(`[Agent] Confidence: ${llmResult.confidence}, Suggested action: ${llmResult.suggestedAction}`);

    // =========================================
    // STEP 5: ACT - Execute any required actions
    // =========================================
    let actionTaken: string | null = null;
    let finalResponse = llmResult.response;
    let ticketStatus = ticket.status;

    if (llmResult.suggestedAction === "refund" && classification.entities.orderId) {
      console.log("[Agent] Step 5: Processing refund request...");

      const refundResult = await this.memory.calculateRefund({
        orderId: classification.entities.orderId,
        reason: classification.intent,
        daysSincePurchase: 15, // Would come from order lookup
        orderTotal: 99.99, // Would come from order lookup
        customerTier: customer.tier,
      });

      if (refundResult.eligible) {
        actionTaken = "refund_approved";
        finalResponse += `\n\nâœ… I've processed a refund of $${refundResult.amount.toFixed(2)} to your original payment method. ${refundResult.policy}`;
      } else {
        finalResponse += `\n\nRegarding the refund: ${refundResult.policy}. However, I'd like to explore other options to help you.`;
      }
    }

    if (llmResult.suggestedAction === "escalate" || llmResult.confidence < 0.4) {
      console.log("[Agent] Step 5: Checking escalation criteria...");

      const escalation = await this.memory.checkEscalationCriteria(currentState);

      if (escalation.shouldEscalate || llmResult.confidence < 0.4) {
        actionTaken = "escalated";
        ticketStatus = "escalated";
        finalResponse += `\n\nğŸ”„ I'm connecting you with a specialist who can better assist with this. They'll be with you shortly.`;
      }
    }

    if (llmResult.suggestedAction === "close_ticket") {
      ticketStatus = "resolved";
      actionTaken = "resolved";
    }

    // Store agent response in working memory
    await this.memory.addToConversation(ticket.id, "agent", finalResponse);

    // Update conversation state
    await this.memory.updateConversationState({
      ...currentState,
      attemptedSolutions: actionTaken ? [actionTaken] : [],
    });

    // =========================================
    // STEP 6: LEARN - Record this interaction
    // =========================================
    console.log("[Agent] Step 6: Recording interaction for learning...");

    await this.memory.recordResolution(
      message,
      finalResponse,
      actionTaken || "response",
      llmResult.reasoning,
      {
        category: classification.intent,
        wasSuccessful: ticketStatus !== "escalated",
        customerSatisfaction: undefined, // Set later from feedback
      }
    );

    console.log(`[Agent] Complete. Status: ${ticketStatus}`);

    return {
      response: finalResponse,
      actionTaken,
      ticketStatus,
    };
  }
}
```

### Step 5: Run the Agent

Create an entry point:

```typescript
// src/index.ts

import "dotenv/config";
import { CustomerSupportAgent } from "./agent";
import { Customer, Ticket } from "./types";

async function main() {
  const agent = new CustomerSupportAgent(
    process.env.SLATE_ADDRESS!,
    process.env.SLATE_TOKEN!,
    process.env.OPENAI_API_KEY!
  );

  // Simulate a customer conversation
  const customer: Customer = {
    id: "cust_123",
    name: "Jane Smith",
    email: "jane@example.com",
    tier: "pro",
    accountAge: 180,
  };

  const ticket: Ticket = {
    id: "ticket_456",
    customerId: customer.id,
    status: "open",
    category: "billing",
    priority: "medium",
    messages: [],
    createdAt: new Date(),
  };

  // First message
  console.log("\n" + "=".repeat(60));
  console.log("CUSTOMER: I've been charged twice for my subscription this month!");
  console.log("=".repeat(60));

  const response1 = await agent.handleMessage(
    ticket,
    customer,
    "I've been charged twice for my subscription this month! This is the second time this has happened and I'm really frustrated. I need this fixed immediately."
  );

  console.log("\nAGENT:", response1.response);
  console.log("\n[Action Taken]:", response1.actionTaken);

  // Follow-up message
  console.log("\n" + "=".repeat(60));
  console.log("CUSTOMER: Yes, please process the refund.");
  console.log("=".repeat(60));

  const response2 = await agent.handleMessage(
    { ...ticket, status: response1.ticketStatus as any },
    customer,
    "Yes, please process the refund. The order ID is ORD-789."
  );

  console.log("\nAGENT:", response2.response);
  console.log("\n[Action Taken]:", response2.actionTaken);
}

main().catch(console.error);
```

---

## Testing

### Unit Tests

```typescript
// tests/agent.test.ts

import { SupportMemory } from "../src/memory";

describe("SupportMemory", () => {
  let memory: SupportMemory;

  beforeEach(() => {
    memory = new SupportMemory("localhost:50051", "test-token");
  });

  describe("calculateRefund", () => {
    it("should approve full refund within 30 days", async () => {
      const result = await memory.calculateRefund({
        orderId: "ORD-123",
        reason: "not_satisfied",
        daysSincePurchase: 15,
        orderTotal: 99.99,
        customerTier: "free",
      });

      expect(result.eligible).toBe(true);
      expect(result.amount).toBe(99.99);
    });

    it("should apply 50% refund for 30-60 day window", async () => {
      const result = await memory.calculateRefund({
        orderId: "ORD-123",
        reason: "not_satisfied",
        daysSincePurchase: 45,
        orderTotal: 100.0,
        customerTier: "free",
      });

      expect(result.eligible).toBe(true);
      expect(result.amount).toBe(50.0);
    });

    it("should give enterprise full refund up to 60 days", async () => {
      const result = await memory.calculateRefund({
        orderId: "ORD-123",
        reason: "not_satisfied",
        daysSincePurchase: 55,
        orderTotal: 100.0,
        customerTier: "enterprise",
      });

      expect(result.eligible).toBe(true);
      expect(result.amount).toBe(100.0);
    });
  });

  describe("checkEscalationCriteria", () => {
    it("should escalate frustrated customers with high risk", async () => {
      const result = await memory.checkEscalationCriteria({
        ticketId: "t1",
        customerId: "c1",
        currentIntent: "complaint",
        sentiment: "frustrated",
        issuesSummary: "Multiple problems",
        attemptedSolutions: [],
        escalationRisk: 0.8,
      });

      expect(result.shouldEscalate).toBe(true);
    });

    it("should escalate after 3 failed attempts", async () => {
      const result = await memory.checkEscalationCriteria({
        ticketId: "t1",
        customerId: "c1",
        currentIntent: "technical",
        sentiment: "neutral",
        issuesSummary: "Technical issue",
        attemptedSolutions: ["reset", "reinstall", "clear_cache"],
        escalationRisk: 0.3,
      });

      expect(result.shouldEscalate).toBe(true);
    });
  });
});
```

---

## How the Memory Systems Work Together

Let's trace through a real interaction to see how the three memory types collaborate:

### Scenario: Returning Customer with Billing Issue

**Turn 1: Customer reaches out**

```
Customer: "I was charged twice again! This happened last month too."
```

1. **Working Memory** receives the message and stores it with timestamp
2. **Episodic Memory** searches for similar issues and finds:
   - This customer's complaint from last month
   - 3 other double-charge resolutions that worked
3. **LLM** sees past successful patterns and generates empathetic response
4. **Episodic Memory** records this new interaction

**Turn 2: Customer provides details**

```
Customer: "Order ID is ORD-789, please refund."
```

1. **Working Memory** retrieves conversation context (previous message)
2. **Procedural Memory** runs refund eligibility calculation
3. **LLM** generates confirmation with exact refund amount
4. **Episodic Memory** records the resolution

**Turn 3: (Future) Similar issue from another customer**

```
New Customer: "I got double charged, what do I do?"
```

1. **Episodic Memory** retrieves the successful resolution pattern
2. **LLM** uses it as a few-shot example for consistent handling

---

## Enhancements

### 1. Sentiment Tracking Over Time

Track how customer sentiment changes during the conversation:

```typescript
async trackSentimentProgression(ticketId: string): Promise<string[]> {
  const history = await this.memory.getConversationHistory(ticketId);
  // Analyze sentiment changes to detect if agent is helping or making things worse
}
```

### 2. Proactive Issue Detection

Use Episodic Memory to detect patterns:

```typescript
async detectRecurringIssues(customerId: string): Promise<{
  hasRecurringIssue: boolean;
  pattern: string;
}> {
  const history = await this.memory.getCustomerHistory(customerId);
  // Detect if same issue has occurred multiple times
  // Proactively offer permanent solutions
}
```

### 3. Agent Performance Analytics

Use stored traces to improve:

```typescript
async getAgentPerformanceMetrics(): Promise<{
  resolutionRate: number;
  avgSatisfaction: number;
  commonEscalationReasons: string[];
}> {
  // Analyze Episodic Memory for patterns
}
```

---

## Summary

In this tutorial, you built a customer support agent that:

- âœ… Maintains conversation context with **Working Memory**
- âœ… Learns from past resolutions with **Episodic Memory**
- âœ… Executes deterministic actions with **Procedural Memory**
- âœ… Improves over time through continuous learning
- âœ… Handles escalations intelligently

The agent demonstrates the core cognitive loop: Perceive â†’ Recall â†’ Orient â†’ Decide â†’ Act â†’ Learn.

::callout{icon="i-lucide-arrow-right" color="primary"}
**Next Tutorial**: [Research Assistant Agent](/tutorials/research-assistant) â€” Build an agent that synthesizes knowledge across sessions and builds a personalized understanding of user interests.
::
