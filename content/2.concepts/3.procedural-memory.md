---
title: Procedural Memory
description: Understanding the procedural memory system for executing compiled skills.
navigation:
  icon: i-lucide-zap
seo:
  title: Procedural Memory
  description: Learn how Procedural Memory enables AI agents to execute deterministic, sandboxed skills via WebAssembly.
---

Procedural Memory executes compiled skills (WebAssembly) server-side. These are deterministic, sandboxed procedures that agents can trigger—like muscle memory that doesn't require thinking.

---

## Key Concepts

### Compiled Skills

Skills are WebAssembly modules that run on the Slate server. They provide:

- **Determinism**: Same input always produces the same output
- **Security**: Sandboxed execution with no access to your infrastructure
- **Speed**: Compiled code runs faster than interpreted scripts
- **Reliability**: No hallucination—these are exact procedures

### When to Use Procedural Memory

Use Procedural Memory when you need:

| Scenario | Why Procedural Memory? |
| :------- | :---------- |
| Financial calculations | Must be exact, no hallucination |
| Data validation | Consistent rules enforcement |
| Format conversion | Deterministic transformations |
| Complex algorithms | Pre-tested, reliable execution |

---

## API Reference

### `trigger(skill_name)`

Execute a server-side WASM skill and get the result.

**Node.js**

```typescript
const result = await client.trigger("calculate_tax");
console.log(`Tax amount: ${result}`);
```

**Python**

```python
result = client.trigger("calculate_tax")
print(f"Tax amount: {result}")
```

---

## Use Cases

### Financial Calculations

Never let an LLM calculate taxes or financial figures—use Procedural Memory.

```typescript
// Instead of asking the LLM to calculate
// Use a deterministic skill
const invoiceTotal = await client.trigger("calculate_invoice_total");
const taxAmount = await client.trigger("calculate_tax");
const finalAmount = await client.trigger("apply_discount");
```

### Data Validation

Validate user input with consistent rules.

```python
# Validate email format, check against blocklist, etc.
validation_result = client.trigger("validate_user_input")

if validation_result.valid:
    proceed_with_action()
else:
    handle_validation_error(validation_result.errors)
```

### Format Conversion

Convert between data formats reliably.

```typescript
// Convert markdown to HTML
const htmlOutput = await client.trigger("markdown_to_html");

// Parse and validate JSON schema
const validatedData = await client.trigger("validate_json_schema");
```

---

## Built-in vs Custom Skills

### Built-in Skills

Slate comes with common utility skills:

- Mathematical operations
- Date/time calculations
- String manipulation
- Data validation

### Custom Skills

Deploy your own WebAssembly modules for domain-specific procedures:

1. Write your skill in Rust, Go, or AssemblyScript
2. Compile to WebAssembly
3. Deploy to your Slate instance
4. Trigger from your agent

::callout{icon="i-lucide-code" color="primary"}
Custom skill deployment documentation coming soon. Contact support for early access.
::

---

## Best Practices

::callout{icon="i-lucide-calculator" color="primary"}
**Use for calculations**: Any math that must be correct should go through Procedural Memory, not the LLM.
::

::callout{icon="i-lucide-shield" color="amber"}
**Security-sensitive operations**: Validation, sanitization, and permission checks belong in Procedural Memory.
::

::callout{icon="i-lucide-repeat" color="blue"}
**Reusable procedures**: If you find yourself prompting the LLM for the same deterministic task, make it a skill.
::
