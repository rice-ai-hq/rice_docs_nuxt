---
title: Semantic Memory
description: Store invariant facts and knowledge for your AI agents.
navigation:
  icon: i-lucide-book-open
seo:
  title: Semantic Memory - Rice Slate
  description: Learn how to use Semantic Memory to store facts, knowledge bases, and reference data for your AI agents.
---

Semantic Memory stores invariant facts and knowledge for agentic use. While Episodic Memory captures experiences and events, Semantic Memory holds general knowledge that remains stable over time.

---

## What is Semantic Memory?

In cognitive science, semantic memory refers to our store of general world knowledge: facts, concepts, and meanings that aren't tied to specific personal experiences. 

In Rice Slate, Semantic Memory provides a structured way to store and retrieve factual knowledge that your agents need to perform their tasks effectively.

---

## Key Characteristics

### Factual Storage

Semantic Memory stores facts, definitions, and reference data. This includes:

- Product specifications
- Company policies
- Domain terminology
- Reference documentation

### Knowledge Relationships

Facts in Semantic Memory can be linked together, creating a knowledge graph that agents can traverse:

- "Product X belongs to Category Y"
- "Policy A supersedes Policy B"
- "Term X is related to Term Y"

### Session-Independent

Unlike Working Memory which is session-scoped, Semantic Memory persists across all agent sessions. Knowledge stored once is available to all future interactions.

---

## Use Cases

### Product Catalogs

Store your entire product catalog with specifications, pricing, and relationships:

```typescript
// Store product knowledge
await slate.semantic.store({
  type: 'product',
  id: 'SKU-12345',
  name: 'Enterprise Widget Pro',
  category: 'Widgets',
  specifications: {
    material: 'Titanium alloy',
    dimensions: '10x5x3 cm',
    weight: '250g'
  },
  related_products: ['SKU-12346', 'SKU-12400']
});

// Query product knowledge
const products = await slate.semantic.query({
  type: 'product',
  category: 'Widgets'
});
```

### Company Policies

Store policies that agents need to reference when making decisions:

```python
# Store policy knowledge
await slate.semantic.store({
    "type": "policy",
    "id": "refund-policy-v2",
    "title": "Refund Policy",
    "effective_date": "2024-01-01",
    "content": "Full refunds within 30 days of purchase...",
    "supersedes": "refund-policy-v1"
})

# Query policies
policy = await slate.semantic.query({
    "type": "policy",
    "id": "refund-policy-v2"
})
```

### Domain Knowledge Bases

Build specialized knowledge for domain-specific agents:

```typescript
// Medical terminology knowledge
await slate.semantic.store({
  type: 'medical_term',
  term: 'hypertension',
  definition: 'Persistently elevated arterial blood pressure',
  related_terms: ['blood pressure', 'cardiovascular'],
  icd_code: 'I10'
});

// Legal knowledge
await slate.semantic.store({
  type: 'legal_concept',
  concept: 'force majeure',
  definition: 'Unforeseeable circumstances preventing contract fulfillment',
  jurisdiction: 'common_law',
  related_concepts: ['act of god', 'impossibility']
});
```

---

## API Reference

### store(knowledge)

Store a piece of knowledge in Semantic Memory.

```typescript
await slate.semantic.store({
  type: string,      // Category of knowledge
  id: string,        // Unique identifier
  // ... additional fields specific to your knowledge type
});
```

### query(filter)

Query knowledge based on type and attributes.

```typescript
const results = await slate.semantic.query({
  type: string,      // Filter by knowledge type
  // ... additional filter criteria
});
```

### link(source_id, target_id, relationship)

Create a relationship between two pieces of knowledge.

```typescript
await slate.semantic.link(
  'product-123',
  'category-widgets',
  'belongs_to'
);
```

### traverse(start_id, relationship, depth)

Traverse knowledge relationships starting from a node.

```typescript
const related = await slate.semantic.traverse(
  'product-123',
  'related_to',
  2  // depth
);
```

---

## Semantic vs Episodic Memory

| Aspect | Semantic Memory | Episodic Memory |
| :----- | :-------------- | :-------------- |
| Content | Facts, definitions, knowledge | Experiences, events, traces |
| Time-bound | No (invariant) | Yes (when it happened) |
| Personal | No (shared) | Yes (agent-specific) |
| Changes | Rarely updated | Continuously growing |
| Example | "Returns allowed within 30 days" | "User returned item on Jan 15" |

---

## Best Practices

### Structure Your Knowledge

Use consistent types and schemas for related knowledge:

```typescript
// Good: Consistent structure
{ type: 'product', id: '...', name: '...', category: '...' }
{ type: 'product', id: '...', name: '...', category: '...' }

// Avoid: Inconsistent structure
{ type: 'product', id: '...', title: '...' }
{ type: 'item', product_id: '...', name: '...' }
```

### Version Your Knowledge

When facts change, version them rather than overwriting:

```typescript
await slate.semantic.store({
  type: 'policy',
  id: 'refund-policy-v2',
  supersedes: 'refund-policy-v1',
  effective_date: '2024-01-01',
  // ...
});
```

### Keep It Factual

Semantic Memory is for stable facts, not volatile data:

```typescript
// Good for Semantic Memory
{ type: 'product', name: 'Widget Pro', sku: 'WP-100' }

// Better for Working Memory (volatile)
{ current_stock: 47, last_updated: '2024-01-15T10:30:00Z' }
```

---

::callout{icon="i-lucide-lightbulb" color="primary"}
**Tip**: Think of Semantic Memory as your agent's "textbook knowledge" and Episodic Memory as its "personal diary". Both are essential for a well-rounded cognitive agent.
::
